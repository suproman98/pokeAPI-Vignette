---
title: "Becoming the Very Best API: Contacting the pokeAPI"
author: "Supro Debnath"
date: '2022-06-18'
---

This vignette is a step-by-step guide to interacting with the [pokeAPI](https://pokeapi.co/docs/v2#info). There are a few functions in here that explore the data present, as well as some visualizations that highlight interesting patterns in the world of pokemon. Most of the ids are represented as numeric (i.e. `Generation 1` referring to the Kanto pokemon, or `Version 8` referring to the Hoenn region). For that reason, if you intend on using any of these functions, please be mindful of how the function inputs correspond to the data you are trying to pull. 

## Requirements

To interact with this API, a few packages must be installed. 
* `jsonlite`: Works with JSON in R and is useful for parsing data and interacting with a web API.
* `httr`: Provides useful tools for working with HTTP.
* `tidyverse`: Collection of R packages that contribute heavily to API interaction and data visualization.
* `knitr`: Provides tools for dynamic reporting in R.
* `dplyr`: Package that provides tools for working with data frames.
* `ggplot2`: Powerful for complex data visualizations.


```{r libraries, message=FALSE, warning=FALSE}
library(jsonlite)
library(httr)
library(tidyverse)
library(knitr)
library(dplyr)
library(ggplot2)
library(ggpubr)
```

## pokeAPI Functions

This section is dedicated to the functions I've created to pull data from this API. 



### `Game Version`

This function pulls the relevant version information of any existing game from the `version` endpoint. It returns a `tibble` listing the name of the game, the region, and which generation it falls into. It takes a numeric input from `1` to `34`, which is the order of each game being introduced.
```{r}
version <- function(game) {
  # Checks if a valid input has been entered into the function.
  if ((game > 34) || (game < 1)) {
    stop("This is an invalid game. Please refine search.")
  }
  
  #Set URL for the version endpoint in the API.
  respGAME <- GET(paste0("http://pokeapi.co/api/v2/version/", game))
  conGAME <- content(respGAME)
  ver <- conGAME$version_group$url %>% GET() %>% content()
  
  #Create a tibble that prints basic version information based on the function input.
  output <- tibble(
    name = ver$name,
    region = ifelse(is_empty(ver$region), NA, ver$regions[[1]]$name),
    generation = ver$generation$name
  )
  return(output)
}
```


### `Generation Pokedex`

This function returns a complete pokedex from the `generation` endpoint. It returns a `data.frame` of pokemon found in that generation, listing their `name`, `id`, `typing` (i.e. fighting type or bug/flying type), `ability` (returning the primary ability, not all pokemon have hidden abilities), and their `stats` (attack, speed, etc.). This function takes a numeric input from `1` to `8`, which is the order of each generation being introduced. 
```{r gendex, warning=FALSE}
gendex <- function(gen) {
  if ((gen > 8) || (gen < 1)) {
    stop("This is a non-existent generation. Please refine search or submit a numeric input from 1 to 8.")
  }
  
  respGEN <- GET(paste0("http://pokeapi.co/api/v2/generation/", gen))
  conGEN <- content(respGEN, "parsed")
  df_pokeGEN <- do.call(rbind.data.frame, c(conGEN$pokemon_species, stringsAsFactors = FALSE))
  
  
  pokePULL <- function(url) {
    specCON <- content(GET(url), "parsed")
    pokeURL <- specCON$varieties[[1]]$pokemon$url
    pokeCON <- content(GET(pokeURL), "parsed")
    stats <- sapply(pokeCON$stats, function(stats) stats[["base_stat"]])
    names(stats) <- sapply(pokeCON$stats, function(stats) stats[["stat"]][["name"]])
    
    for (i in seq_along(pokeCON$types)) {
      if (pokeCON$types[[i]][["slot"]] == 1){
        type <- pokeCON$types[[1]][["type"]][["name"]]
      }
      else {
        type <- paste0(pokeCON$types[[1]][["type"]][["name"]], "/",      
                       pokeCON$types[[2]][["type"]][["name"]])
      }
    }
    
    for (i in seq_along(pokeCON$abilities)) {
      if (pokeCON$abilities[[i]][["slot"]] == 1) {
        ability <- pokeCON$abilities[[1]][["ability"]][["name"]]
      } 
    }
    
    return(
      c(
        name = pokeCON$name,
        pokedex_id = pokeCON$id,
        type = type,
        ability = ability,
        weight = pokeCON$weight,
        as.list(stats)
      )
    )
  }
  
  pokeLIST <- lapply(df_pokeGEN$url, pokePULL)
  pokedex <- do.call(rbind.data.frame, c(pokeLIST, stringsAsFactors = FALSE))
  pokedex <- pokedex %>% arrange(pokedex_id)
  return(pokedex)
}
```

```{r}
gendex(3)
```


### `TypeDex`

This function returns a complete list of moves from the `type` endpoint. It returns a `data.frame` of moves found in that type, listing their `name`, `id`, `accuracy`, `power`, `pp` (how many times the move can be used), `crit` (whether it can critically strike), `drain` (whether the move drains health from the opponent), and `flinch` (the chance the move causes the enemy to flinch. This function takes a numeric input from `1` to `20`, which is the number of types present. 
```{r}
typedex <- function(type) {
  if ((type > 20) || (type < 1)) {
    stop("This is a non-existent typing. Please refine search or submit a numeric input from 1 to 20.")
  }
  
  respTYPE <- GET(paste0("http://pokeapi.co/api/v2/type/", type))
  conTYPE <- content(respTYPE, "parsed")
  df_typeGEN <- do.call(rbind.data.frame, c(conTYPE$moves, stringsAsFactors = FALSE))

  typePULL <- function(url) {
    moveCON <- content(GET(url), "parsed")
    
    
    if (is.null(moveCON$accuracy)) {
        moveCON$accuracy = "NA"
    }
    
    if (is.null(moveCON$power)) {
        moveCON$power = "NA"
    }
    
    return(
      c(
        name = moveCON$name,
        move_id = moveCON$id,
        accuracy = moveCON$accuracy,
        power = moveCON$power,
        pp = moveCON$pp,
        crit = moveCON$meta$crit_rate,
        drain = moveCON$meta$drain,
        flinch = moveCON$meta$flinch_chance
      )
    )
  }
  
  typeLIST <- lapply(df_typeGEN$url, typePULL)
  typedex <- do.call(rbind.data.frame, c(typeLIST, stringsAsFactors = FALSE))
  names(typedex) <- c('name', 'move_id', 'accuracy', 'power', 'pp', 'crit_rate', 'drain', 'flinch_chance')
  typedex <- type.convert(typedex)
  return(typedex)
}
```



### `Region`

```{r}
region <- function(reg) {
  if ((reg > 8) || (reg < 1)) {
    stop("This is a non-existent region. Please refine search or submit a numeric input from 1 to 796.")
  }
  
  respREG <- GET(paste0("https://pokeapi.co/api/v2/region/", reg))
  conREG <- content(respREG, "parsed")
  df_pokeREG <- do.call(rbind.data.frame, c(conREG$locations, stringsAsFactors = FALSE))
  
  
  locPULL <- function(url) {
    locCON <- content(GET(url), "parsed")
    areaURL <- locCON$areas[[1]]$url
    areaCON <- content(GET(areaURL), "parsed")

    return(
      c(
        name = areaCON$name,
        area_id = areaCON$id,
        pokemon = areaCON$pokemon_encounters$pokemon$name,
        chance = areaCON$pokemon_encounters$version_details$encounter_details$chance,
        level = areaCON$pokemon_encounters$version_details$encounter_details$max_level
      )
    )
  }
  
  regLIST <- lapply(df_pokeREG$url, locPULL)
  regdex <- do.call(rbind.data.frame, c(regLIST, stringsAsFactors = FALSE))
#  locdex <- pokedex %>% arrange(pokedex_id)
  return(regdex)
}
```






### `pokeAPI Wrapper Function`
```{r}
pokeAPI <- function(func, ...){
  ###
  # This function is a wrapper for the other functions. It takes in the name
  # of the function to use as a character and any additional arguments for that
  # function.
  ###
  
  # Find and call the appropriate function using conditional logic.
  
  if (func == "version"){
    output <- version(...)
  }
  else if (func == "gen"){
    output <- gendex(...)
  }
  else if (func == "type"){
    output <- typedex(...)
  }
  else {
    stop("ERROR: Argument for func is not valid!")
  }
  
  # Return the output from the appropriate function.
  return(output)
}
```


```{r kanto}
kanto <- pokeAPI("gen", 1)
kanto <- kanto %>% mutate(totalstats = hp+attack+defense+special.attack+special.defense+speed)
head(kanto)
```


```{r kanto strongest}
plot1 <- top_n(kanto, n=15, totalstats) %>% ggplot(., aes(x=name, y=totalstats, fill=type)) + geom_bar(stat='identity') + theme(axis.text.x = element_text(angle=45))
plot1
```


```{r kanto type}
plot2 <- ggplot(kanto, aes(x=totalstats)) + geom_histogram()
plot2
```


```{r kanto type table, warning=FALSE}
table1 <- table(kanto$type)
knitr::kable(table1, col.names = gsub("[.]", " ", names(c("Type Combo", "Count"))))
```


```{r attack v defense kanto, message=FALSE, warning=FALSE}
plot3 <- ggplot(kanto, aes(x=attack, y=defense)) + geom_point(stat='identity') + geom_smooth() + stat_cor(mapping = NULL, data = NULL, method = "pearson", alternative = "two.sided")
plot3
```


```{r kanto boxplot}
plot4 <- ggplot(kanto, aes(x=type, y=totalstats, fill=type)) + geom_boxplot(show.legend = FALSE) + geom_jitter(shape=16, position=position_jitter(0.2)) + coord_flip() + theme(legend.position = "none")
plot4
```




```{r hoenn}
hoenn <- pokeAPI("gen", 3)
hoenn <- hoenn %>% mutate(totalstats = hp+attack+defense+special.attack+special.defense+speed, avg_total = (totalstats/6))
head(hoenn)
```


```{r hoenn strongest}
plot5 <- top_n(hoenn, n=15, totalstats) %>% ggplot(., aes(x=name, y=totalstats, fill=type)) + geom_bar(stat='identity') + theme(axis.text.x = element_text(angle=45))
plot5
```


```{r hoenn type}
plot6 <- ggplot(hoenn, aes(x=totalstats))  + geom_histogram()
plot6
```




```{r attack v defense hoenn, message=FALSE, warning=FALSE}
plot7 <- ggplot(hoenn, aes(x=attack, y=defense)) + geom_point(stat='identity') + geom_smooth() + stat_cor(mapping = NULL, data = NULL, method = "pearson", alternative = "two.sided")
plot7
```


```{r hoenn boxplot}
plot8 <- ggplot(hoenn, aes(x=type, y=totalstats, fill=type)) + geom_boxplot(show.legend = FALSE) + geom_jitter(shape=16, position=position_jitter(0.2)) + coord_flip() + theme(legend.position = "none")
plot8
```

